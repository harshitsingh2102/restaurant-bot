/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import { LroEngine } from "@azure/core-lro";
import { LroImpl } from "./lroImpl";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
/** @internal */
export class ConversationAnalysisClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the ConversationAnalysisClient class.
     * @param endpoint Supported Cognitive Services endpoint (e.g.,
     *                 https://<resource-name>.api.cognitiveservices.azure.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-language-conversations/1.0.0-beta.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{Endpoint}/language" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2022-05-15-preview";
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Analyzes the input conversation utterance.
     * @param task A single conversational task to execute.
     * @param options The options parameters.
     */
    analyzeConversation(task, options) {
        return this.sendOperationRequest({ task, options }, analyzeConversationOperationSpec);
    }
    /**
     * Submit a collection of conversations for analysis. Specify one or more unique tasks to be executed.
     * @param task The collection of conversations to analyze and one or more tasks to execute.
     * @param options The options parameters.
     */
    async beginConversationAnalysis(task, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperation = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON()
                }
            };
        };
        const lro = new LroImpl(sendOperation, { task, options }, conversationAnalysisOperationSpec);
        const poller = new LroEngine(lro, {
            resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
        });
        await poller.poll();
        return poller;
    }
    /**
     * Submit a collection of conversations for analysis. Specify one or more unique tasks to be executed.
     * @param task The collection of conversations to analyze and one or more tasks to execute.
     * @param options The options parameters.
     */
    async beginConversationAnalysisAndWait(task, options) {
        const poller = await this.beginConversationAnalysis(task, options);
        return poller.pollUntilDone();
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const analyzeConversationOperationSpec = {
    path: "/:analyze-conversations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeConversationTaskResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse,
            headersMapper: Mappers.ConversationAnalysisClientAnalyzeConversationExceptionHeaders
        }
    },
    requestBody: Parameters.task,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "json",
    serializer
};
const conversationAnalysisOperationSpec = {
    path: "/analyze-conversations/jobs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeConversationJobState
        },
        201: {
            bodyMapper: Mappers.AnalyzeConversationJobState
        },
        202: {
            bodyMapper: Mappers.AnalyzeConversationJobState
        },
        204: {
            bodyMapper: Mappers.AnalyzeConversationJobState
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.task1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "json",
    serializer
};
//# sourceMappingURL=conversationAnalysisClient.js.map